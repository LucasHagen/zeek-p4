\chapter{\TheSolutionName{}}
\label{cap:proposal}

In this chapter, we propose the \TheSolutionName{}, a sole
ution for offloading some of Zeek's operations discussed in Section \ref{sec:candidate_operations} to programmable forwarding devices compatible with P4. The proposal builds on top of the Reconfigurable Network Analytics (RNA) architecture, which was initially proposed by Ilha \cite{Ilha2022}. Since \TheSolutionName{} advances RNA, next we describe the solution resulting from both, highlighting the new functionality.

\begin{figure}[h]
    \caption{RNA architecture - high-level architectural view}
    \begin{center}
        \includegraphics[width=0.7\textwidth]{images/arch_high_level.pdf}  
    \end{center}
    \label{fig:arch_high_level}
    \legend{Source: the author, adapted from Ilha \cite{Ilha2022}}
\end{figure}

% TODO: bypass some operations that would be costly (such as X and Y)
% TODO(2): What step? ... one step closer (i.e., Z)
Figure \ref{fig:arch_high_level} illustrates the RNA architecture. It is composed of two high-level components: the RNA Host Engine, which executes in one of Zeek's work nodes inside the IDS; and the RNA Switch Engine, which is executed in a P4 switch. Both components work together to offload packet analysis from Zeek to a programmable forwarding device. The RNA Switch Engine is able to parse packets and identify some of their characteristics, which are then summarized and sent to the RNA Host Engine. This summarized message is called mRNA. When the IDS receives this message, it is first processed by our Host Engine. It then converts the summarized message into Zeek's native structures, which can then be forwarded to Zeek's normal processing pipeline. This procedure allows us to bypass some operations that would be costly, and deliver this information one step closer to the Policy Script Interpreter (PSI, Section \ref{sec:zeek_psi}), without disturbing Zeek's flow. By doing so, we make it that no change is required on existing scripts running on the PSI.

% TODO: check what to call this "'custom software' to be executed both...."
In the original concept of RNA, depending on the IDS scripts chosen to be monitored by the operator, it is necessary to develop custom software to be executed both by the Host Engine and the Switch Engine. This ad-hoc development process quickly becomes impractical when we increase the number of desired scripts to be offloaded. For this reason, we propose an automatic code generation mechanism, described later in Section \ref{sec:code_gen}, which allows \TheSolutionName{} to be a modular solution, where varying combinations of Zeek scripts can be chosen to be monitored, without the need to develop new software. Before detailing this automated process, we briefly review the operation of RNA components.

% ==============================================================================
%                               RNA OVERVIEW
% ==============================================================================
\section{RNA Components in a Nutshell}

Using Figure \ref{fig:arch_high_level} as a reference, we present the components of the RNA architecture and their functionality. We start with the RNA Host Engine, since it is the controlling part of the whole deployment, and then we describe the RNA Switch Engine.

% TODO: check if we'll remove the "RNA Event Handler" completely, or say it was removed but exists in the original RNA
% TODO(2): Por que o negrito agora e não na primeira vez em que o nome do componente foi referido (ainda no trecho anterior)? Há que estabelecer e seguir rigorosamente um critério.
The \textbf{Host Engine} unfolds into two components. The \textbf{RNA Manager} is the controlling component of the deployment, which first configures the P4 switch, setting up a monitoring session and loading all P4 code that is required to execute the offloaded tasks. After configuring the switch, it registers all RNA Translators (one per-protocol of interest), so they receive mRNA messages. \textbf{Translators} are components responsible for waiting for such mRNA messages and translating them to Zeek native structures. Those structures are then used to trigger events, which are then consumed by the running scripts.

The \textbf{RNA Switch Engine} is the program that executes in our P4-compatible programmable forwarding device. It has three components and we'll be following the route of an incoming packet to explain them. The first component that processes a packet is the \textbf{RNA Parser}. It parses and extracts headers from each protocol, from the link layer, up to the application layer if required. After all the headers have been extracted, the packet enters P4's ingress pipeline, where the \textbf{RNA Transcriber} is executed. It extracts useful information from the packet and sets metadata that later will be used to build our summarized message, while also filtering some undesired packets. Having all the required metadata and going into P4's egress pipeline, the \textbf{RNA Splicer} builds and sends our summarized message, the mRNA, to the Host Engine with all information it may require to trigger a native Zeek Event.

% TODO: negrito no \textbf{mRNA Message}
Another important structure is the \textbf{mRNA Message}. It is a summary of a packet, summarizing all the information that the Switch Engine was able to extract from it. Sending an mRNA message is more efficient than sending a whole packet because the original packet contains headers that would still need to be parsed, information that, in come cases, is not necessary, and is not validated. In the summarized message, all information from L2 up to the L7 layer is gathered, filtered, and, in some cases, even formatted according to Zeek's native structures, saving Zeek from doing these operations on its own. The information-gathering process still needs to happen, but it does in the Switch Engine, which runs in a purpose-built device, making it much more efficient for this task. So the more information the switch is able to extract, the less Zeek has to do.

In an ideal world scenario, we would like to extract all information that Zeek needs to trigger an event, but sometimes that is not possible. Zeek's internal structures track connection states and use detection heuristics, which, because of P4's limited processing power for general tasks, we are unable to implement. This requires the mRNA message to be modular, allowing us to send, together with it, a part of the packet that was not able to be processed in the switch. This ensures P4 extracts all information it can, leaving the rest for Zeek to finish analyzing.

% ==============================================================================
%                               RNA DETAILED ARCHITECTURE
% 
%  This includes modifications made to allow code generation
% ==============================================================================
\section{Detailed Architecture}

The \TheSolutionName{} was based on the RNA architecture, with the addition of modules that could be added and removed as the network operator wants to offload different scripts. Before explaining the inner details of the architecture, we will introduce two concepts that are fundamental for its understanding and will serve as inputs later for our code generator tool. Those concepts are \ProtocolTemplate{} and \Offloader{}:

\begin{itemize}
    \item An \textbf{\Offloader{}} is a set of files and settings that allows \TheSolutionName{} to offload a new script. Like the idea of a module, it can be added and removed to the deployment, without needing to develop new software or change existing components.

    \item A \textbf{\ProtocolTemplate{}} is a set of files and settings that allows \TheSolutionName{} to parse a new protocol. An \Offloader{} requires a set of \ProtocolTemplates{} to be able to parse and offload the desired scripts.
\end{itemize}

In order to explain the details of the architecture behind the \TheSolutionName{}, presented in Figure \ref{fig:arch_low_level}, we use an example of an incoming ICMPv4 ping (\textsc{ICMP Echo Request}) packet and its trajectory through a deployed instance of the \TheSolutionName{}.

\begin{figure}[H]
    \caption{\TheSolutionName{} and RNA Framework - Detailed architectural view}
    \begin{center}
        \includegraphics[width=0.7\textwidth]{images/arch_low_level.pdf}  
    \end{center}
    \label{fig:arch_low_level}
    \legend{Source: the author}
\end{figure}

\subsection{Switch Engine}

As the packet arrives at the P4-switch, it is first processed by the programmable parser. The \textbf{RNA Parser} component is a state machine with all the parsers the \Offloaders{} may need. Each one extracts its headers from the packet, and forwards the payload to the next parser.

In our example which is shown in Figure \ref{fig:icmp_ex_parser}, the first parser would be the Ethernet parser, extracting its header, followed by the IPv4 and ICMP parsers. In the example figure, we also display other states of parsers that were not identified. When the Ethernet header is parsed, the next protocol is defined by the \texttt{ethertype} field, which in this case was the IPv4 protocol. The states and protocols displayed by dotted lines were possible protocols the deployment could parse, but since the packet was an ICMP, those parsers were not used.

\begin{figure}[ht]
    \caption{Parsing States - ICMP Parsing Example}
    \begin{center}
        \includegraphics[width=0.7\textwidth]{images/icmp_ex_parser.pdf}  
    \end{center}
    \label{fig:icmp_ex_parser}
    \legend{Source: the author}
\end{figure}



The \textbf{RNA Transcriber} is the first component to be executed after the packets have their headers parsed, this happens in the ingress pipeline. It's purpose is to extract information from the incoming packets and store them in the metadata. In this component, as shown in Figure \ref{fig:arch_low_level}, there are two types of modules, the Protocol Preprocessors, and the Offloader Triggers, both of which may have multiple instances. We start explaining the Protocol Preprocessors since they are the first modules to be executed inside this component.

The Protocol Preprocessors are functions that every \ProtocolTemplate{} may execute to extract protocol metadata from the packet. This module is optional and every \ProtocolTemplate{} may have only one preprocessor. In our example, the processor extracts the ICMP type from the header and saves it in the metadata.

The next modules to be executed in the Transcriber are the Offloader Triggers, which are conditions that identify which \Offloader{} should be triggered. Each of these conditions is checked, and the first \Offloader{} to have its trigger condition valid is marked as the triggered one in the packet's metadata. In our example of an ICMP echo request, our trigger condition is \texttt{icmp.type = 8}. This ensures the \Offloader{} \textsc{ICMP Echo Request} is triggered when a ping packet arrives.

% Maybe add here a code snippet

After a valid \Offloader{} is found, a copy of this packet is created and using this cloned packet, the switch will be able to construct the mRNA message. The original packet will follow its flow and be delivered to the originally intended destination. The next component we present is the Splicer component, where the construction of the summarized message starts.

The \textbf{RNA Splicer} is executed after the packet leaves the ingress pipeline and it enters the egress pipeline\footnotemark{}. The RNA Splicer is composed of two different types of Splicers, the RNA Base Splicer and the Offloader Splicers.

The \textbf{RNA Base Splicer} constructs the base headers for the mRNA message. These headers contains general information, which all \Offloaders{} can use. This includes, for example, source IP, destination IP, L3, and L4 protocols. In our example, the RNA Base Splicer sets both source and destination IPs, the L3 protocol to \texttt{IPv4}, and L4 protocol to \texttt{ICMP}. The Base Splicer is executed for every triggered \Offloader{}. In our expanded version of the RNA architecture, we use two headers to construct our mRNA message: the RNA Header, which only contains the version of the protocol, and the type of RNA message; and the RNA Offloader Header, which is also a general header used by multiple \Offloaders{} which contains the information described above. Instead of using only one header that contains all the information for the offloaders, we decided to use two headers to allow for more expandability in the future, for example, adding a debugging messages.

The second type of Splicers are the \textbf{Offloader Splicers}. These are splicers that every \Offloader{} may have. Each \Offloader{} Splicer constructs the header with the extra information required to execute its functionality. In our example, the \textsc{ICMP Echo Request} Splicer will construct a header with information about the ICMP packet: \texttt{type}, \texttt{code}, \texttt{sequence}, and \texttt{id}.
% Maybe add code snippets here too

\footnotetext{Since we are explaining the architecture behind \TheSolutionName{}, we are not considering the inner workings of the programmable data plane, where a buffer connects the ingress and egress pipeline.}

After every Splicer has finished constructing its headers, the mRNA message will be ready. The payload and headers, which together form the mRNA, are then merged and sent to Zeek's monitoring interface, effectively finishing the processing on the Switch Engine. From now on, Zeek's Translators will work to support the monitoring infrastructure.

\subsection{Host Engine}

In this section, we describe how the Host Engine receives the mRNA messages and uses them to execute the monitoring scripts. Figure \ref{fig:arch_low_level} shows the first components to receive the mRNA message are the Translators. In Zeek's architecture, there is one module responsible for analyzing each protocol, which is called Analyzers. Every Analyzer parses its respective headers and forwards the payload to the next one.

The first Analyzer to receive the mRNA message is the Ethernet Analyzer. This is the first Analyzer to be executed because the mRNA message is built over the Ethernet protocol. Since the Ethernet Analyzer is a Zeek internal component and not a part of the RNA architecture, it is not displayed in Figure \ref{fig:arch_low_level}. This Analyzer, using the \texttt{ethertype} code, forwards then every received packet to the Analyzer responsible for parsing the next protocol layer. In this example, the ethertype field is going to indicate it is an RNA Message, forwarding to the RNA Analyzer and entering the RNA Translator component.

The \textbf{RNA Analyzer} is the first Analyzer of the RNA architecture to receive the mRNA packet. As explained in the previous section, the RNA protocol has a generic header that indicates the version and the message type. In the case of this project, the only type we use is the \Offloader{} type\footnotemark. Using our previously described example, the mRNA packet created for the ICMP ping will have its type as \textsc{\Offloader{}}.

\footnotetext{There are actually three types of \Offloaders{}, but for simplification purposes, in the architecture description we present the Offloader type as being one unique type. For more details about this, please refer to implementation details (Section \ref{sec:implementation}).}

Next, the \textbf{RNA Offloader Analyzer} is the second Analyzer of our RNA implementation to receive the mRNA packet. It parses common information that is used by most \Offloaders{}, for example, source and destination IP addresses, L3 and L4 protocols, and \Offloader{} type. This Analyzer is also responsible for forwarding the mRNA packet to the \Offloader{} specific Analyzer by using the \Offloader{} \texttt{type} code. In our example, the next Analyzer to be called is the \textsc{ICMP Echo Request} Analyzer.



\section{Code Generation}
\label{sec:code_gen}

% Introduction

\subsection{Requirements or Usage}

% Describe how it is actually used to generate the code and then to deploy

\subsection{Details}

% Describe how to actually works and maybe some implementation details
