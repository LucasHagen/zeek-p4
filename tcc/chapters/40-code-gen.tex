\chapter{Automatic Code Generation for RNA}
\label{cap:code_gen}

% Introduction

In this chapter, we present a mechanism for automatic code generation for the RNA Framework. This enables network operators to deploy the framework without having the experience and knowledge to develop software for Zeek or programmable forwarding devices (P4).

The code generation mechanism uses two sets of inputs: the scripts, whose events should be offloaded; a pool of \ProtocolTemplates{} and \Offloader{} Templates. The previously mentioned concepts, the \ProtocolTemplates{} and the \Offloaders{} are used as sources of templates and resources, in order to implement the software required to offload the events subscribed by the desired scripts. We also propose the generation of a unique Zeek Plugin, which will automatically deploy the P4 code when initiated, instead of having two separate deployable components.

\section{Overview}
\label{sec:code_gen:overview}

This section presents an overview of the RNA Code Generation Mechanism, starting with its inputs and expected output, which is illustrated in Figure \ref{fig:code_gen_black_box}. The main input for the mechanism is the set of scripts, whose monitoring the network operator is interested in. These scripts need to be provided in their entirety, so we can identify the events to which they subscribe.

\begin{figure}[htb]
    \caption{RNA - Code Generation Mechanism}
    \begin{center}
        \includegraphics[width=0.98\textwidth]{images/code_gen_mechanism.pdf}
    \end{center}
    \label{fig:code_gen_black_box}
    \legend{Source: the author}
\end{figure}

The second set of inputs is what we call \textit{templates}, which can be either  \ProtocolTemplates{} or \Offloader{} Templates. They are a pool of known implementations of protocols and events that can be used to offload scripts. A template being present in this pool does not mean it will be included in the final output, but it means it is available in case its implementation is needed by a script.

The desired output of our mechanism is a single Zeek Plugin following the structure previously presented in Section \ref{sec:rna:overview} and illustrated in Figure \ref{fig:arch_low_level}. This Zeek Plugin when executed should: configure the switch, creating a mirroring session for the Zeek monitoring system, deploying the P4 code; and configure Zeek, registering all Translators in Zeek's Event Engine, and registering the RNA Event Handler. This eliminates the need for the operator to coordinate the deployment of two separate systems, the RNA Host Engine, and the RNA Switch Engine.

To be able to execute this task, the first objective of the code generation process is to analyze all the provided Zeek scripts and identify which are the observed events in every script. Once this pool of events is known, we select \Offloaders{} (from the templates pool) that are capable of offloading those events. This step is finished and succeeds if we find at least one \Offloader{} for every event.

After all events and \Offloaders{} have been selected, the mechanism must ensure all templates for the protocols required by these \Offloaders{} are available. The \ProtocolTemplates{} are required so the \Offloaders{} can interpret the desired headers. After all this knowledge model is complete, the mechanism generates all required source files.

Some of the resulting code that is present in the final Zeek Plugin is extracted and merged from the templates, and not completely generated by our mechanism. It is not yet possible to fully generate all offloader code, because the process of converting C++ or P4 code from one to another is very complicated and is out of the scope of this project.


% 
% Pode revisar at√© aqui :)
% 

\section{Detailed Mechanism Design}
\label{sec:code_gen_impl}

The operation of our RNA Code Generation Mechanism can be classified into three different stages. The first stage parses the input scripts to identify the events they subscribe to. The second stage is building our knowledge model, which receives as inputs all \ProtocolTemplates{}, \Offloaders{}, and events of interest, which the network operator requested to be offloaded. We call this knowledge model \textit{ProtocolGraph}. The second stage is the actual code merge and generation process using this structured and validated knowledge model from the previous step. We start explaining the first stage of our mechanism, the process of building our knowledge model.

\subsection{Knowledge Model}

The core logic behind the implementation of our RNA Code Generation Mechanism relies on a structure we call \textit{ProtocolGraph}. This structure stores in a graph structure all protocols required for our events of interest. The \Offloaders{} are linked to their final protocol level in the graph, generating us a structure as presented in Figure \ref{fig:protocol_graph}.

\begin{figure}[htb]
    \caption{Knowledge Model - Protocol Graph}
    \begin{center}
        \includegraphics[width=0.98\textwidth]{images/icmp_ex_protocol_graph.pdf}  
    \end{center}
    \label{fig:protocol_graph}
    \legend{Source: the author}
\end{figure}

% def build(self):
%     """Builds the graph and validates it.
%     """
%     self._validate_component_list(self.raw_components)

%     protocol_list = _filter_list_by_type(
%         self.raw_components, ProtocolComponent)
%     offloader_list = _filter_list_by_type(
%         self.raw_components, OffloaderComponent)

%     self.required_offloaders = self._get_required_offloaders(offloader_list)

%     if len(self.required_offloaders) == 0:
%         raise ZpoException("No Offloader or Zeek Event specified for offloading. Aborting.")

%     # Remove not required offloaders
%     offloader_list = _filter_list(
%         lambda offloader: offloader.id in self.required_offloaders, offloader_list)

%     self.protocols: Dict[str, ProtocolComponent] = _make_template_dict(
%         protocol_list)
%     self.offloaders: Dict[str, OffloaderComponent] = _make_template_dict(
%         offloader_list)

%     self.root = self._find_root_protocol()

%     self._link_graph()
%     self._attach_offloaders()
%     self._check_for_cycles()
%     self._trim_unused_protocols()
%     self._remove_unreachable_protocols()

%     self._set_protocol_depths()
%     self._sort_protocols()
%     self._sort_offloaders()
%     self._set_offloaders_uids()

%     self.is_built = True
% Describe how to actually works and maybe some implementation details


\subsection{Code Generation}